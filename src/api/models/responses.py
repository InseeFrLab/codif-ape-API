from typing import Any, Dict, Mapping, Union

from pydantic import BaseModel, RootModel, model_validator


class Prediction(BaseModel):
    code: str
    probabilite: float
    libelle: str


class OutputResponse(RootModel[Dict[str, Union[Prediction, float, str]]]):
    """
    Contract for the output response of the API including:
    - KV of PredictionResponse: normalized prediction responses generated by the model artifact
    - MLversion: run_id as version of the ML model

    Expected flat structure after normalization:

    {
    "1": Prediction,
    "2": Prediction,
    ...,
    "IC": float,      # required confidence score
    "MLversion": str  # required run_id as model version
    }

    Notes:
    - The output reflects what the model artifact produces, but the API applies
    `model_dump()` in `predict()` before returning to ensure schema consistency.
    - Any changes to the output schema (e.g., new fields, renaming) must be documented
    both here and in training repo (codif-ape-training) to maintain API contract clarity.
    """

    @model_validator(mode="after")
    @classmethod
    def _normalize(cls, data: Any) -> "OutputResponse":
        # unwrap root if called with an instance
        raw = data.root if isinstance(data, cls) else data

        if not isinstance(raw, Mapping):
            raise TypeError("OutputResponse: expected a dict/mapping")

        # IC (required) - accept numbers or numeric strings
        try:
            ic = float(raw["IC"])
        except KeyError:
            raise ValueError("OutputResponse: missing required key 'IC'")
        except (TypeError, ValueError) as e:
            raise ValueError(f"OutputResponse: 'IC' not convertible to float: {e}") from e

        # MLversion (required)
        try:
            ml_version = str(raw["MLversion"])
        except KeyError:
            raise ValueError("OutputResponse: missing required key 'MLversion'")
        except Exception as e:
            raise ValueError(f"OutputResponse: 'MLversion' not convertible to str: {e}") from e

        # allow only digit keys + IC + MLversion
        allowed = {k for k in raw.keys() if k.isdigit()} | {"IC", "MLversion"}
        extra = set(raw.keys()) - allowed
        if extra:
            raise ValueError(f"OutputResponse: unexpected keys: {sorted(extra)}")

        # ensure digit keys map to Prediction
        for k in (k for k in raw.keys() if k.isdigit()):
            val = raw[k]
            if not isinstance(val, (Mapping, Prediction)):
                raise ValueError(
                    f"OutputResponse: value for key '{k}'must be a mapping or Prediction"
                )

        # normalize in place
        normalized = dict(raw)
        normalized["IC"] = ic
        normalized["MLversion"] = ml_version

        data.root = normalized
        return data
