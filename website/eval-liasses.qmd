---
title: "Evaluation d'un mod√®le"
---

## Connexion √† l'API et ajout des donn√©es

```{ojs}
viewof username = Inputs.password({label: html`<b>Set username</b>`, value: ""})
```

```{ojs}
viewof password = Inputs.password({label: html`<b>Set password</b>`, value: ""})

```

```{ojs}
viewof csvfile = Inputs.file({
  label: md`__Observations to evaluate__ üìÅ ([Example here](https://raw.githubusercontent.com/ThomasFaria/codif-ape-API/main/website/exemples/exemple.csv))`,
  accept: ".csv",
  required: true
})
```

## Distribution des indices de confiances

```{ojs}
grid = await html`<div style="
              background: #fff;
              margin: 0;
              border: none ;
              display: grid;
              width: ${screen.width};
              grid-template-areas:
                'a b c'
                'd d d'
                ;
              grid-gap: 10px;
            ">
              <div name="a" style="grid-area: a; position: relative;">${viewof quantile}</div>
              <div name="b" style="grid-area: b; position: relative;"><div class="textstyled">Accuracy: ${Accuracy}</div></div>
              <div name="c" style="grid-area: c; position: relative;"><div class="textstyled">Seuil: ${Seuil}</div></div>
              <div name="d" style="grid-area: d; position: relative;">${distrib}</div>
            </div>`
```


```{ojs}
viewof quantile = Inputs.range([0, 100], {label: "Taux de classification automatique", step: 1, value: 80})
```

```{ojs}
distrib = Plot.plot({
  round: true,
  width: screen.width * 0.7,
  color: { scheme: "BuRd", legend: true },
  marks: [
    Plot.rectY(
      processed_response,
      Plot.binX(
        { y: "count" },
        { x: "IC", fill: "Result", mixBlendMode: "multiply", tip: true }
      )
    ),
    Plot.ruleY([0]),
    Plot.ruleX([Seuil], { strokeWidth: 2, tip: true })
  ]
})
```

```{ojs}
Seuil = Math.round(
  d3.quantile(
    processed_response.map((d) => d.IC),
    1 - quantile / 100
  ) * 100
) / 100
```

```{ojs}
Accuracy = Math.round(d3.mean(subset.map((d) => d.IC)) * 10000) / 100
```

```{ojs}
Inputs.table(processed_response)
```


## Taux de classification automatique sur IC



```{ojs}
Plot.plot({
  grid: true,
  y: {
    label: "‚Üë Indice de confiance"
  },
  x: {
    label: "‚Üí Taux de classification automatique"
  },
  marks: [
    Plot.line(ic_tx_classif, {
      x: "quantiles",
      y: "seuils",
      stroke: "black",
      strokeWidth: 2
    }),
    Plot.tip(
      ic_tx_classif,
      Plot.pointer({
        x: "quantiles",
        y: "seuils",
        title: (d) => `Accuracy : ${get_accuracies_from_threshold(
          ic_tx_classif,
          d.seuils
        )}\nIC : ${
          Math.round(d.seuils * 100) / 100
        }\nTaux classification automatique
${d.quantiles}`
      })
    )
  ],
  color: { legend: true }
})
```

## Liste des mauvaises predictions

```{ojs}
WrongPredictions = Inputs.table(subset.filter((d) => 1 - d.Result))
```

<!-- Data stuffs -->

```{ojs}
data = db.query(
  `
SELECT text_description, type_, nature, surface, event, code
FROM liasses
`
)
```

```{ojs}
transformedData = data.reduce((acc, obj) => {
  for (const [key, value] of Object.entries(obj)) {
    if (!acc.hasOwnProperty(key)) {
      acc[key] = [];
    }
    acc[key].push(value);
  }
  return acc;
}, {})
```

```{ojs}
db = DuckDBClient.of({
  liasses: await csvfile.csv()
})
```

```{ojs}
processed_response = Object.keys(response.IC).map((key) => ({
  IC: response.IC[key] > 1 ? 1 - 1e-16 : response.IC[key],
  Probability: response.Probability[key],
  Prediction: response.Prediction[key],
  Code: response.Code[key],
  Result: response.Result[key],
  Lib: response.Lib[key]
}))
```

```{ojs}
response = queryBatchApi(username, password, data)
```

```{ojs}
subset = processed_response.filter((d) => d.IC > Seuil)
```

```{ojs}
ic_tx_classif = {
  const newArray = [];
  for (let i = 0; i < quantiles.length; i++) {
    newArray.push({ quantiles: quantiles[i], seuils: seuils[i] });
  }
  return newArray;
}
```

```{ojs}
quantiles = Array.from({ length: 101 }, (_, i) => i/100) // Array with quantile values from 0 to 1
```

```{ojs}
seuils = quantiles.map((quantile) =>
  d3.quantile(
    processed_response.map((d) => d.IC),
    1 - quantile
  )
)
```


<!-- Functions -->

```{ojs}
async function queryBatchApi(username, password, data) {
  const url = "https://codification-ape.lab.sspcloud.fr/evaluation";

  // Create the request body
  const request_body = data.reduce((acc, obj) => {
    for (const [key, value] of Object.entries(obj)) {
      if (!acc.hasOwnProperty(key)) {
        acc[key] = [];
      }
      acc[key].push(value);
    }
    return acc;
  }, {});

  const response = await fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Basic ${btoa(`${username}:${password}`)}`
    },
    body: JSON.stringify(request_body)
  });

  if (response.ok) {
    return response.json();
  } else if (response.status === 400) {
    console.log((await response.json()).detail);
  } else {
    console.log("Error occurred while querying the API.");
    return response;
  }
}
```

```{ojs}
function get_accuracies_from_threshold(d, threshold) {
  let acc = d3.mean(
    processed_response.filter((d) => d.IC > threshold).map((d) => d.IC)
  );
  acc = acc === undefined ? 1 : Math.round(acc * 100) / 100;
  return acc;
}
```

<!-- Imports -->

```{ojs}
Plot = require("https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6.8/dist/plot.umd.min.js")
```

